import 'dart:async';
import 'dart:convert';

import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:pokedex/localization/localize.dart';
import 'package:source_gen/source_gen.dart';

class LocalizationGenerator extends GeneratorForAnnotation<Localize> {
  @override
  FutureOr<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    final name = annotation.read('name').literalValue! as String;
    final path = annotation.read('path').literalValue! as String;

    final jsonContent = await buildStep.readAsString(
      AssetId(buildStep.inputId.package, path),
    );

    final localizationMap = jsonDecode(jsonContent) as Map<String, dynamic>;

    // Generate the Dart code
    final buffer = StringBuffer();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln(
      '// **************************************************************************',
    );
    buffer.writeln('// This file was generated by Kung.kittisak@bitkub.com');
    buffer.writeln(
      '// **************************************************************************',
    );
    buffer.writeln();
    buffer.writeln('class ${name}Localization {');
    localizationMap.forEach((key, value) {
      buffer.writeln('  final String $key;');
    });
    buffer.writeln();
    buffer.writeln('  ${name}Localization({');
    localizationMap.forEach((key, value) {
      buffer.writeln('    required this.$key,');
    });
    buffer.writeln('  });');
    buffer.writeln();
    buffer.writeln(
      '  factory ${name}Localization.fromRemoteConfig(Map<String, dynamic> remoteConfig) {',
    );
    buffer.writeln('    return ${name}Localization(');
    localizationMap.forEach((key, value) {
      buffer.writeln('      $key: remoteConfig["$key"] ?? "$value",');
    });
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');

    return buffer.toString();
  }
}
